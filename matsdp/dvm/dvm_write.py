def write_input(pos_file_path, dvm_input_dict = None):
    '''
    Description:
    Write the *.input file for a DVM calculation based on the atom position file (*.incar or POSCAR format)
    Currently, for the pos_file_path, only the POSCAR format is supported. In the future the *.incar will also be surpported and the automatic file format recognition should be used.
    pos_file_path: the file path for the file which contains the atom coordinates, now the POSCAR file is supported.
    dvm_input_dict: the dictionary which contains the input parameters of the *.input file. If dvm_input_dict = None, then the default value of the parameters in the *.input file will be used
    '''
    import os
    import numpy as np
    from .. import funcs
    from .. import default_params
    from ..vasp import vasp_read
    from . import dvm_default
    from . import dvm_help
 
    defaults_dict = default_params.default_params()
    logfile = defaults_dict['logfile']
    output_dir = os.getcwd() + '/' + defaults_dict['output_dir_name']

    dvm_help_dict = dvm_help.dvm_help()

    # set the predefined value of parameters in the .input file
    # grid3dinfo
    grid3dinfo_str = '600   1.00000   2.00000'
    # frozeninfo
    dvm_frozeninfo_dict = {}
    dvm_frozeninfo_dict['Al'] = '3  100  200 210'
    dvm_frozeninfo_dict['Ti'] = '5  100  200 210 300 310'
    dvm_frozeninfo_dict['Cr'] = '5  100  200 210 300 310'
    dvm_frozeninfo_dict['Co'] = '5  100  200 210 300 310'
    dvm_frozeninfo_dict['Ni'] = '5  100  200 210 300 310'
    dvm_frozeninfo_dict['Mo'] = '8  100  200 210 300 310 320 400 410'
    dvm_frozeninfo_dict['Ru'] = '8  100  200 210 300 310 320 400 410'
    dvm_frozeninfo_dict['Hf'] = '12  100  200 210 300 310 320 400 410 420 430 500 510'
    dvm_frozeninfo_dict['Ta'] = '12  100  200 210 300 310 320 400 410 420 430 500 510'
    dvm_frozeninfo_dict['W'] = '12  100  200 210 300 310 320 400 410 420 430 500 510'
    dvm_frozeninfo_dict['Re'] = '12  100  200 210 300 310 320 400 410 420 430 500 510'
    dvm_frozeninfo_dict['Ir'] = '12  100  200 210 300 310 320 400 410 420 430 500 510'
    dvm_frozeninfo_dict['Au'] = '12  100  200 210 300 310 320 400 410 420 430 500 510'

    dvm_input_header ='''#------------------------------------------------------------------------------- 
#
#  This is the master input file of DVDAC
#  
#  Note the policy is one line for one keyword only. If one line is 
#  not enough for a keyword, you can use "&" at the end of the line 
#  to continue the input. "&" must be at the end will take effect!
#
#  Keyword can be written at any place in the file. If there are more 
#  than two, only the first one will be read.
#
#  Use "#" and "!" for comment. Any thing after them will be ignored.   
#
#------------------------------------------------------------------------------- 



'''

    # atom position file
    pos_file_path = os.path.abspath(pos_file_path)
    # designate the working directory
    workdir, pos_file = funcs.file_path_name(pos_file_path)

    # extract the job name
    file_list = os.listdir(workdir)
    for i_file in file_list:
        if 'incar' in i_file:
            job_name = i_file[0:-6]

    # recognize the type of the atom position file (in the future the automatic file type recognition shoud be incorprated)
    #pos_file_type = 'dvm_incar'
    pos_file_type = 'POSCAR'

    if pos_file_type == 'POSCAR':
        poscar_dict = vasp_read.read_poscar(pos_file_path)
        with open(pos_file_path, 'r') as f_poscar:
            lines = f_poscar.readlines()
            elmt_species_arr = poscar_dict['elmt_species_arr']
            n_atoms = poscar_dict['n_atoms']

    dvm_input_default_dict = dvm_default.input_default()
    if dvm_input_dict == None:
        dvm_input_dict = dvm_input_default_dict
        dvm_input_dict['jobid'] = '\"' + ''.join(elmt_species_arr) + '. Generated by matsdp\"'
        dvm_input_dict['nbasis'] = len(elmt_species_arr)
        dvm_input_dict['natom'] = n_atoms
        # frozeninfo
        frozeninfo = ''
        for indx in range(0,len(elmt_species_arr)):
            i_species = elmt_species_arr[indx]
            if indx < len(elmt_species_arr) - 1:
                frozeninfo = frozeninfo + dvm_frozeninfo_dict[i_species] + '    &   ! ' + i_species + '\n' + ' ' * 17
            else:
                frozeninfo = frozeninfo + dvm_frozeninfo_dict[i_species] + '    ! ' + i_species 
        dvm_input_dict['frozeninfo'] = frozeninfo
        # grid3dinfo
        grid3dinfo = ''
        for indx in range(0,len(elmt_species_arr)):
            i_species = elmt_species_arr[indx]
            if indx < len(elmt_species_arr) - 1:
                grid3dinfo = grid3dinfo + grid3dinfo_str + '     &' + '\n' + ' ' * 17
            else:
                grid3dinfo = grid3dinfo + grid3dinfo_str
        dvm_input_dict['grid3dinfo'] = grid3dinfo
        
    else:
        temp_dict = dvm_input_default_dict.copy()
        temp_dict.update(dvm_input_dict)
        dvm_input_dict = temp_dict
        
    input_str = ''
    input_str = input_str + dvm_input_header
    for item in range(0,len(dvm_input_dict)):
        input_key = list(dvm_input_dict.keys())[item]
        input_key = input_key + ' ' * (13 - len(input_key))
        input_value = list(dvm_input_dict.values())[item]
        input_value_str = str(input_value)
        if len(input_value_str) >= 13:
            input_value_str = input_value_str + ' ' * 4
        else:
            input_value_str = input_value_str + ' ' * (13 - len(input_value_str))
        input_help_value = list(dvm_help_dict.values())[item]
        input_str = input_str + '  '+ input_key + '= ' + input_value_str + ' ' + str(input_help_value) + '\n'
        if input_key.strip() == 'ifdebug':
            input_str = input_str + '\n\n\n'
        if input_key.strip() == 'frozeninfo':
            input_str = input_str + '\n'
        if input_key.strip() == 'grid3dinfo':
            input_str = input_str + '\n'

    dest_input_file_path = workdir + '/' + job_name + '.input' 
    with open(dest_input_file_path,'w') as f_dest_input:
        f_dest_input.write(input_str)
    funcs.write_log(
        logfile,
        'dvm_write.write_input(\n' + 
        '    pos_file_path = ' + 'r\'' + str(pos_file_path) + '\',' + '\n' +
        '    dvm_input_dict = ' + str(None) + ')\n' +
        '#######################\n'
        )
    return input_str

def write_ind(pos_file_path, elmt_ind_file_dir):
    '''
    Description:
    write the IND.DAT file for a DVM calculation
    pos_file_path: the file path for the file which contains the atom coordinates, now the POSCAR file is supported.
    elmt_ind_file_dir: the directory which contains the element IND.DAT files. The element IND.DAT files if the file with IND.DAT information of each element
    '''
    import os
    from .. import funcs
    from ..vasp import vasp_read
    from .. import default_params
    defaults_dict = default_params.default_params()
    logfile = defaults_dict['logfile']
    output_dir = os.getcwd() + '/' + defaults_dict['output_dir_name']

    # atom position file and element potential file
    pos_file_path = os.path.abspath(pos_file_path)
    elmt_ind_file_dir = os.path.abspath(elmt_ind_file_dir)
    # designate the working directory
    workdir, pos_file = funcs.file_path_name(pos_file_path)

    # recognize the type of the atom position file (in the future the automatic file type recognition shoud be incorprated)
    #pos_file_type = 'dvm_incar'
    pos_file_type = 'POSCAR'

    if pos_file_type == 'POSCAR':
        poscar_dict = vasp_read.read_poscar(pos_file_path)
        with open(pos_file_path, 'r') as f_poscar:
            lines = f_poscar.readlines()
            elmt_species_arr = poscar_dict['elmt_species_arr']
        # concatenate IND.DAT files of elements
        ind_file_path = workdir + '/IND.DAT'
        with open(ind_file_path, 'w') as f_ind:
            pass
        with open(ind_file_path, 'a') as f_ind:
            for i_elmt_name in elmt_species_arr:
                elmt_ind_file = 'IND_' + i_elmt_name + '.DAT'
                elmt_ind_file_path = elmt_ind_file_dir + '/' + elmt_ind_file
                with open(elmt_ind_file_path, 'r') as f_elmt_ind:
                    lines = f_elmt_ind.readlines()
                    for i_line in lines:
                        f_ind.write(i_line)
                f_ind.write('\n0.\n')
            f_ind.write(' -1 THAT\'S ALL.')
    funcs.write_log(
        logfile,
        'dvm_write.write_ind(\n' +
        '    pos_file_path = ' + 'r\'' + str(pos_file_path) + '\',' + '\n' +
        '    elmt_ind_file_dir = ' + 'r\'' + str(elmt_ind_file_dir) + '\')\n' +
        '########################\n'
        )
    return 0

def write_ie(dvm_otput_file_path):
    '''
    Interatomic energy between the atoms and their nearest neighbor atoms.
    This module has been tested for the source_23oct05 version of the DVM program
    dvm_otput_file_path: the *.otput file of the DVM output
    '''
    import os
    import numpy as np
    from .. import funcs
    from .. import convert
    from ..vasp import vasp_read
    from ..vasp import vasp_analyze
    from . import dvm_read
    from .. import default_params

    defaults_dict = default_params.default_params()
    logfile = defaults_dict['logfile']
    output_dir = os.getcwd() + '/' + defaults_dict['output_dir_name']
    funcs.mkdir(output_dir)

    dvm_otput_file_path = os.path.abspath(dvm_otput_file_path)
    # designate the working directory
    workdir, dvm_otput_file = funcs.file_path_name(dvm_otput_file_path)

    dvm_incar_file_path = workdir + '/' + dvm_otput_file[0:-6] + '.incar'
    convert.dvmincar2poscar(dvm_incar_file_path)
    dvmincar2poscar_poscar_file_path = workdir + '/' + dvm_otput_file[0:-6] + '_dvmincar2poscar.vasp'
    poscar_dict = vasp_read.read_poscar(dvmincar2poscar_poscar_file_path)
    atom_name_list = poscar_dict['atomname_list']
    atom_indx_arr = poscar_dict['atom_indx_arr'] 
    n_atoms = poscar_dict['n_atoms']
    added_atom_data_arr = poscar_dict['added_atom_data']
    dvm_otput_dict = dvm_read.read_otput(dvm_otput_file_path)

    ie_au_arr = None
    ie_au_up_arr = None
    ie_au_dw_arr = None
    if dvm_otput_dict['spin'] == 0:
        ie_au_arr = np.array([None] * n_atoms * n_atoms)
        ie_au_arr.shape = n_atoms, n_atoms
        for i_atom in range(0, n_atoms):
            for j_atom in range(0, n_atoms):
                ie_au_arr[i_atom, j_atom] = dvm_otput_dict['ie_arr'][int(added_atom_data_arr[i_atom, 3]) - 1, int(added_atom_data_arr[j_atom, 3]) - 1]
    if dvm_otput_dict['spin'] == 1:
        ie_au_up_arr = np.array([None] * n_atoms * n_atoms)
        ie_au_up_arr.shape = n_atoms, n_atoms
        ie_au_dw_arr = np.array([None] * n_atoms * n_atoms)
        ie_au_dw_arr.shape = n_atoms, n_atoms
        for i_atom in range(0, n_atoms):
            for j_atom in range(0, n_atoms):
                ie_au_up_arr[i_atom, j_atom] = dvm_otput_dict['ie_up_arr'][int(added_atom_data_arr[i_atom, 3]) - 1, int(added_atom_data_arr[j_atom, 3]) - 1]
                ie_au_dw_arr[i_atom, j_atom] = dvm_otput_dict['ie_dw_arr'][int(added_atom_data_arr[i_atom, 3]) - 1, int(added_atom_data_arr[j_atom, 3]) - 1]

    # the output indices based on the atom names
    # write the data into files
    ie_au_file_path = workdir + '/' + dvm_otput_file[0:-6] + '_ie_au_all_atoms.txt'
    ie_ev_file_path = workdir + '/' + dvm_otput_file[0:-6] + '_ie_ev_all_atoms.txt'
    with open(ie_au_file_path, 'w') as f_ie_au, open(ie_ev_file_path, 'w') as f_ie_ev:
        pass
    with open(ie_au_file_path, 'a') as f_ie_au, open(ie_ev_file_path, 'a') as f_ie_ev:
        for i_atom in range(0, n_atoms):
            i_atom_str = atom_name_list[i_atom] + ' (' + str(added_atom_data_arr[i_atom, 3]) + ')'
            atom_name_str = ', '.join([str(x) + ' (' + str(added_atom_data_arr[atom_name_list.index(x), 3]) + ')' + ' ' * (13 - len(str(x) + ' (' + str(added_atom_data_arr[atom_name_list.index(x), 3]) + ')')) for x in atom_name_list]) + '\n'

            if dvm_otput_dict['spin'] == 0:
                temp_au_arr = ie_au_arr[i_atom,:]
                temp_ev_arr = temp_au_arr * convert.unitconvert('a.u.','eV')
                ie_au_str = ', '.join([str(x) + ' ' * (13 - len(str(x))) for x in temp_au_arr]) + '\n'
                ie_ev_str = ', '.join(['{:.4f}'.format(x) + ' ' * (13 - len('{:.4f}'.format(x))) for x in temp_ev_arr]) + '\n'
                f_ie_au.write(
                    i_atom_str + ' ' * (13 - len(i_atom_str)) + ', ' + 
                    atom_name_str +
                    ' IE (a.u.)' + ' ' * (13 - len(' IE (a.u.)')) + ', ' +
                    ie_au_str
                    )
                f_ie_ev.write(
                    i_atom_str + ' ' * (13 - len(i_atom_str)) + ', ' + 
                    atom_name_str +
                    ' IE (eV)'  + ' ' * (13 - len(' IE (eV)')) + ', ' +
                    ie_ev_str
                    )
            if dvm_otput_dict['spin'] == 1:
                temp_au_up_arr = ie_au_up_arr[i_atom,:]
                temp_ev_up_arr = temp_au_up_arr * convert.unitconvert('a.u.','eV')
                temp_au_dw_arr = ie_au_dw_arr[i_atom,:]
                temp_ev_dw_arr = temp_au_dw_arr * convert.unitconvert('a.u.','eV')
                ie_au_up_str = ', '.join([str(x) + ' ' * (13 - len(str(x))) for x in temp_au_up_arr]) + '\n'
                ie_ev_up_str = ', '.join(['{:.4f}'.format(x) + ' ' * (13 - len('{:.4f}'.format(x))) for x in temp_ev_up_arr]) + '\n'
                ie_au_dw_str = ', '.join([str(x) + ' ' * (13 - len(str(x))) for x in temp_au_dw_arr]) + '\n'
                ie_ev_dw_str = ', '.join(['{:.4f}'.format(x) + ' ' * (13 - len('{:.4f}'.format(x))) for x in temp_ev_dw_arr]) + '\n'
                f_ie_au.write(
                    i_atom_str + ' ' * (13 - len(i_atom_str)) + ', ' + 
                    atom_name_str +
                    ' IE (a.u.) up' + ' ' * (13 - len(' ' * len(' IE (a.u.) up'))) + ', ' +
                    ie_au_up_str +
                    ' IE (a.u.) dw' + ' ' * (13 - len(' ' * len(' IE (a.u.) dw'))) + ', ' +
                    ie_au_dw_str
                    )
                f_ie_ev.write(
                    i_atom_str + ' ' * (13 - len(i_atom_str)) + ', ' + 
                    atom_name_str +
                    ' IE (eV) up' + ' ' * (13 - len(' ' * len(' IE (eV) up'))) + ', ' +
                    ie_ev_up_str +
                    ' IE (eV) dw' + ' ' * (13 - len(' ' * len(' IE (eV) dw'))) + ', ' +
                    ie_ev_dw_str
                    )


    # the output indices based on the DVM atom indices
    # write the data into files
    ie_au_dvm_indx_file_path = workdir + '/' + dvm_otput_file[0:-6] + '_ie_au_all_atoms_dvm_index.txt'
    ie_ev_dvm_indx_file_path = workdir + '/' + dvm_otput_file[0:-6] + '_ie_ev_all_atoms_dvm_index.txt'
    with open(ie_au_dvm_indx_file_path, 'w') as f_ie_au_dvm_indx, open(ie_ev_dvm_indx_file_path, 'w') as f_ie_ev_dvm_indx_:
        pass
    with open(ie_au_dvm_indx_file_path, 'a') as f_ie_au_dvm_indx, open(ie_ev_dvm_indx_file_path, 'a') as f_ie_ev_dvm_indx:
        for i_dvm_atom_indx in range(1, n_atoms + 1):
            #i_atom = int(list(added_atom_data_arr[:, 3]).index(str(i_dvm_atom_indx)))
            i_atom = int(np.argwhere(added_atom_data_arr[:, 3] == str(i_dvm_atom_indx)))
            i_dvm_indx_str = str(i_dvm_atom_indx) + ' (' + atom_name_list[i_atom] + ')'
            dvm_atom_indx_str = ', '.join([str(x) + ' (' + atom_name_list[int(np.argwhere(added_atom_data_arr[:, 3] == str(x)))] + ')' + ' ' * (13 - len(str(x) + ' (' + atom_name_list[int(np.argwhere(added_atom_data_arr[:, 3] == str(x)))] + ')')) for x in list(range(1, n_atoms + 1))]) + '\n'

            if dvm_otput_dict['spin'] == 0:
                temp_au_arr = dvm_otput_dict['ie_arr'][i_dvm_atom_indx -1 , :]
                temp_ev_arr = temp_au_arr * convert.unitconvert('a.u.','eV')
                ie_au_str = ', '.join([str(x) + ' ' * (13 - len(str(x))) for x in temp_au_arr]) + '\n'
                ie_ev_str = ', '.join(['{:.4f}'.format(x) + ' ' * (13 - len('{:.4f}'.format(x))) for x in temp_ev_arr]) + '\n'
                f_ie_au_dvm_indx.write(
                    i_dvm_indx_str + ' ' * (13 - len(i_dvm_indx_str)) + ', ' + 
                    dvm_atom_indx_str +
                    ' IE (a.u.)' + ' ' * (13 - len(' IE (a.u.)')) + ', ' +
                    ie_au_str
                    )
                f_ie_ev_dvm_indx.write(
                    i_dvm_indx_str + ' ' * (13 - len(i_dvm_indx_str)) + ', ' + 
                    dvm_atom_indx_str +
                    ' IE (eV)'  + ' ' * (13 - len(' IE (eV)')) + ', ' +
                    ie_ev_str
                    )
            if dvm_otput_dict['spin'] == 1:
                temp_au_up_arr = dvm_otput_dict['ie_up_arr'][i_dvm_atom_indx -1 , :]
                temp_ev_up_arr = temp_au_up_arr * convert.unitconvert('a.u.','eV')
                temp_au_dw_arr = dvm_otput_dict['ie_dw_arr'][i_dvm_atom_indx -1 , :]
                temp_ev_dw_arr = temp_au_dw_arr * convert.unitconvert('a.u.','eV')
                ie_au_up_str = ', '.join([str(x) + ' ' * (13 - len(str(x))) for x in temp_au_up_arr]) + '\n'
                ie_ev_up_str = ', '.join(['{:.4f}'.format(x) + ' ' * (13 - len('{:.4f}'.format(x))) for x in temp_ev_up_arr]) + '\n'
                ie_au_dw_str = ', '.join([str(x) + ' ' * (13 - len(str(x))) for x in temp_au_dw_arr]) + '\n'
                ie_ev_dw_str = ', '.join(['{:.4f}'.format(x) + ' ' * (13 - len('{:.4f}'.format(x))) for x in temp_ev_dw_arr]) + '\n'
                f_ie_au_dvm_indx.write(
                    i_dvm_indx_str + ' ' * (13 - len(i_dvm_indx_str)) + ', ' + 
                    dvm_atom_indx_str +
                    ' IE (a.u.) up' + ' ' * (13 - len(' ' * len(' IE (a.u.) up'))) + ', ' +
                    ie_au_up_str +
                    ' IE (a.u.) dw' + ' ' * (13 - len(' ' * len(' IE (a.u.) dw'))) + ', ' +
                    ie_au_dw_str
                    )
                f_ie_ev_dvm_indx.write(
                    i_dvm_indx_str + ' ' * (13 - len(i_dvm_indx_str)) + ', ' + 
                    dvm_atom_indx_str +
                    ' IE (eV) up' + ' ' * (13 - len(' ' * len(' IE (eV) up'))) + ', ' +
                    ie_ev_up_str +
                    ' IE (eV) dw' + ' ' * (13 - len(' ' * len(' IE (eV) dw'))) + ', ' +
                    ie_ev_dw_str
                    )
    funcs.write_log(
        logfile,
        'dvm_write.write_ie(\n' + 
        '    dvm_otput_file_path = ' + 'r\'' + str(dvm_otput_file_path) + '\')\n' +
        '#######################\n'
        )
    return ie_au_arr, ie_au_up_arr, ie_au_dw_arr

